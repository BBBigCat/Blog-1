---
title: '前言'
date: 2019-08-28
permalink: 'data-structures-introduction'
---

参考 **GitHub** 上 **5W** **star** 的 [javascript-algorithms](https://github.com/trekhleb/javascript-algorithms) 数据结构与算法项目以及多种资料，加上自己理解并记录整理，有对应的源码地址，本系列中出现的所有测试一律使用 [jest](https://jestjs.io/) 进行测试，对 jest 不熟悉的朋友也可以看我总结的 [jest 系列](/passages/automated-testing-learn-introduction/)

#### 复杂度分析

20 个最常用的、最基础数据结构与算法，数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树、递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

时间复杂度与**常量**无关，比如 **100**，**10000** 这种，只会随着常量的增加，执行效率和时间逐渐增加，跟 **n** 并没有什么关联

一个 for 循环是 O(n) 两个 for 循环嵌套就是 O(n^2)

加法法则：取最大的时间复杂度

乘法法则：嵌套代码的复杂度等于嵌套内外代码的乘积，比如有个嵌套是 O(n)，一个是 O(n^2) 那么他们总的嵌套复杂度是 O(n^3)

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)

复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

四、常用的复杂度级别？

多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O (1)（常数阶）、O (logn)（对数阶）、O (n)（线性阶）、O (nlogn)（线性对数阶）、O (n^2)（平方阶）、O (n^3)（立方阶）

非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O (2^n)（指数阶）、O (n!)（阶乘阶）

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们集作 O (1)
不同数据规模，无法评估 m 和 n 的量级大，所以不能利用加法法则，去掉某一个，而是 O (m+n)

空间复杂度：表示算法的存储空间与数据规模之间的增加关系

一、复杂度分析的 4 个概念

1. 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。
2. 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。
3. 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
4. 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。**基本上均摊结果就等于低级别复杂度**
